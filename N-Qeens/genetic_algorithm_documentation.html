<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA-Inspired N-Queens Solver</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;500;600;700;800&family=SF+Pro+Display:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../stylesheet.css">
    <!-- Favicons -->
    <link rel="icon" type="image/x-icon" href="https://artarazaz.github.io/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="https://artarazaz.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://artarazaz.github.io/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://artarazaz.github.io/apple-icon-180x180.png">
    <style>
        #dna-container {
            position: fixed;
            top: 0;
            right: 10%;
            width: 150px;
            height: 100vh;
            perspective: 1000px;
            z-index: -1;
            opacity: 0.35;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #dna-helix {
            width: 100%;
            height: 120%;
            /* Slightly taller to prevent gaps */
            transform-style: preserve-3d;
            transition: transform 0.1s ease-out;
            /* Smooth stop */
        }

        .base-pair {
            position: absolute;
            width: 100%;
            height: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transform-style: preserve-3d;
        }

        .base {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }

        .bond {
            flex-grow: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 5px;
        }

        /* Base colors */
        .base.a {
            color: #ff3366;
            background: #ff3366;
        }

        .base.t {
            color: #3366ff;
            background: #3366ff;
        }

        .base.g {
            color: #33cc33;
            background: #33cc33;
        }

        .base.c {
            color: #ffcc00;
            background: #ffcc00;
        }

        /* Timeline on the left for LTR (English) */
        .timeline.timeline-left::before {
            right: auto;
            left: var(--spacing-md);
        }

        .timeline.timeline-left .timeline-item {
            padding-right: var(--spacing-md);
            padding-left: var(--spacing-xl);
        }

        .timeline.timeline-left .timeline-item::before {
            right: auto;
            left: calc(var(--spacing-md) - 6px);
        }

        .timeline.timeline-left .timeline-item:hover {
            transform: translateX(8px);
        }
    </style>
</head>

<body>
    <div id="dna-container">
        <div id="dna-helix">
            <!-- Dynamically generated or static base pairs -->
            <script>
                const helix = document.getElementById('dna-helix');
                const pairCount = 40;
                const types = [
                    ['a', 't'],
                    ['t', 'a'],
                    ['g', 'c'],
                    ['c', 'g']
                ];

                for (let i = 0; i < pairCount; i++) {
                    const pair = document.createElement('div');
                    pair.className = 'base-pair';
                    pair.style.top = `${(i / pairCount) * 100}%`;
                    pair.style.transform = `rotateY(${i * 20}deg)`;

                    const type = types[i % 4];
                    pair.innerHTML = `
                        <div class="base ${type[0]}"></div>
                        <div class="bond"></div>
                        <div class="base ${type[1]}"></div>
                    `;
                    helix.appendChild(pair);
                }

                let lastScroll = window.scrollY;
                let currentRotation = 0;

                window.addEventListener('scroll', () => {
                    const scrollY = window.scrollY;
                    const delta = scrollY - lastScroll;

                    // Rotate based on scroll delta
                    // Sensitivity: delta * 0.5 deg
                    currentRotation += delta * 0.5;
                    helix.style.transform = `rotateY(${currentRotation}deg)`;

                    lastScroll = scrollY;
                }, { passive: true });
            </script>
        </div>
    </div>
    <div class="top-nav-container">
        <div class="nav-left">
            <a href="genetic_fa.html" class="nav-btn language-toggle">Fa</a>
        </div>
        <div class="nav-right">
            <a href="../index_en.html" class="nav-btn home-btn">Home</a>
            <div class="hamburger-menu nav-btn" id="hamburgerMenu" role="button" tabindex="0" aria-expanded="false"
                aria-controls="navMenu">
                <div class="hamburger-icon" aria-hidden="true">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                <div class="hamburger-panel">
                    <nav class="nav-menu" id="navMenu">
                        <a href="../index_en.html">Home</a>
                        <a href="../projects_en.html">Projects</a>
                        <a href="../CV.html">CV</a>
                        <a href="../aboutme_en.html">About Me</a>
                        <a href="../contact_me_en.html">Contact Me</a>
                    </nav>
                </div>
            </div>
        </div>
    </div>
    <script>
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const hamburgerIcon = hamburgerMenu.querySelector('.hamburger-icon');

        function toggleMenu() {
            const isOpen = hamburgerMenu.classList.toggle('open');
            hamburgerMenu.setAttribute('aria-expanded', String(isOpen));
        }
        hamburgerIcon.addEventListener('click', function (e) {
            e.stopPropagation();
            toggleMenu();
        });
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.hamburger-menu')) {
                hamburgerMenu.classList.remove('open');
                hamburgerMenu.setAttribute('aria-expanded', 'false');
            }
        });
        document.addEventListener('keydown', function (e) {
            if ((e.key === 'Enter' || e.key === ' ') && e.target === hamburgerMenu) {
                e.preventDefault();
                toggleMenu();
            }
        });
    </script>

    <div class="hero">
        <h1>DNA-Inspired N-Queens Solver</h1>
        <p class="subtitle">A Novel Approach Using Base-Pair Encoding & Constrained Random Generation</p>
        <div class="meta-info">
            <span class="meta-tag">Technical Documentation</span>
            <span class="meta-tag">Research Project</span>
            <span class="meta-tag">Algorithm Analysis</span>
        </div>
    </div>

    <div class="container">
        <!-- Table of Contents -->
        <div class="nav-section">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#overview">1. Overview</a></li>
                <li><a href="#biological-inspiration">2. Biological Inspiration from DNA</a></li>
                <li><a href="#algorithm-architecture">3. Algorithm Architecture</a></li>
                <li><a href="#implementation-details">4. Implementation Details</a></li>
                <li><a href="#function-reference">5. Function Reference</a></li>
                <li><a href="#performance-analysis">6. Performance Analysis</a></li>
                <li><a href="#comparison">7. Comparison with Classical Genetic Algorithm</a></li>
                <li><a href="#usage">8. Usage Guide</a></li>
                <li><a href="#complexity">9. Computational Complexity</a></li>
            </ul>
        </div>

        <section id="overview" class="section">
            <h2><span class="section-icon"></span>1. Overview</h2>
            <p>
                This document describes a novel approach to solving the N-Queens problem, inspired by the base-pairing
                rules of DNA. The N-Queens problem is a classic combinatorial challenge: place N non-attacking queens
                on an N√óN chessboard so that no two queens threaten each other (i.e., no two queens may share a row,
                column, or diagonal).
            </p>
            <p>
                This approach differs from most standard genetic algorithms that place queens at random and then
                evolve them. We use a constrained generation strategy that mimics DNA base-pair arrangements and
                ensures that valid solutions are produced from the outset.
            </p>
        </section>

        <section id="biological-inspiration" class="section">
            <h2><span class="section-icon"></span>2. Biological Inspiration from DNA</h2>

            <h3>Watson‚ÄìCrick base-pairing rules</h3>
            <p>
                DNA is made up of four nucleotides: Adenine (A), Thymine (T), Guanine (G), and Cytosine (C). These
                bases pair according to specific complementary rules:
            </p>
            <ul>
                <li><strong>A ‚Üî T:</strong> Adenine always pairs with Thymine</li>
                <li><strong>G ‚Üî C:</strong> Guanine always pairs with Cytosine</li>
            </ul>
            <p>
                These base-pairing rules create a stable, self-consistent double-helix structure. The DNA helix is
                not only structurally elegant but also a highly efficient way to store genetic information.
            </p>

            <h3>Mapping to N-Queens</h3>
            <p>
                We map these pairing rules by mapping each queen to a <em>pair of positions</em>:
            </p>
            <ul>
                <li>Each pair specifies one queen placement that violates no row, column, or diagonal constraint.</li>
                <li>Like DNA bases that form complementary pairs, queen positions are computed so that validity is
                    guaranteed from the start.</li>
            </ul>
        </section>

        <section id="algorithm-architecture" class="section">
            <h2><span class="section-icon"></span>3. Algorithm Architecture</h2>

            <h3>Main steps</h3>
            <div class="grid-2">
                <div class="card">
                    <h4>Step 1: Pre-compute pairs</h4>
                    <p>
                        The <code>calculate_pairs()</code> function builds a list of all valid (row, column) pairs. A
                        pair is valid only if placing a queen there does not violate the N-Queens rules.
                    </p>
                </div>
                <div class="card">
                    <h4>Step 2: Constrained random selection</h4>
                    <p>
                        The <code>create_list()</code> function randomly selects <code>N/2</code> pairs and builds the
                        full list of queen positions, producing a complete solution.
                    </p>
                </div>
            </div>
            <div class="grid-2">
                <div class="card">
                    <h4>Step 3: Solution validation</h4>
                    <p>
                        The <code>validation()</code> function checks that no two queens attack each other. It
                        guarantees that the generated solution satisfies all N-Queens constraints.
                    </p>
                </div>
                <div class="card">
                    <h4>Step 4: Uniqueness check</h4>
                    <p>
                        The <code>check()</code> function ensures the solution is not a duplicate of one already
                        found. This step prevents repeated solutions from being stored.
                    </p>
                </div>
            </div>

            <h3>Workflow</h3>
            <div class="timeline timeline-left">
                <div class="timeline-item">
                    <h4>Start</h4>
                    <p>Begin the N-Queens solving process</p>
                </div>
                <div class="timeline-item">
                    <h4>Pre-compute valid pairs</h4>
                    <p>Build the list of all valid (row, column) pairs for the board</p>
                </div>
                <div class="timeline-item">
                    <h4>Solution generation loop</h4>
                    <p>Repeat until enough solutions have been found</p>
                </div>
                <div class="timeline-item">
                    <h4>Random pair selection</h4>
                    <p>Randomly select N/2 pairs from the list</p>
                </div>
                <div class="timeline-item">
                    <h4>Build queen list</h4>
                    <p>Convert selected pairs into the position array</p>
                </div>
                <div class="timeline-item">
                    <h4>Validation</h4>
                    <p>Check that queens do not conflict in columns or diagonals</p>
                </div>
                <div class="timeline-item">
                    <h4>Uniqueness check</h4>
                    <p>Confirm the solution has not been found before</p>
                </div>
                <div class="timeline-item">
                    <h4>Store solution</h4>
                    <p>Add the valid solution to the results list</p>
                </div>
                <div class="timeline-item">
                    <h4>End</h4>
                    <p>Finish once the requested number of solutions is reached</p>
                </div>
            </div>
        </section>

        <section id="implementation-details" class="section">
            <h2><span class="section-icon"></span>4. Implementation Details</h2>

            <h3>1. Pre-compute pairs</h3>
            <p>
                This function generates all possible (i, j) pairs where i ‚àà [0, N-1] and j ‚àà [0, N-1]. Pre-computation
                means the pair list is built only once, reducing computational overhead.
            </p>
            <div class="code-block">
                <pre><code>def calculate_pairs(board_size):
    pairs = []
    for i in range(board_size):
        for j in range(board_size):
            pairs.append([i, j])
    return pairs</code></pre>
            </div>

            <h3>2. Constrained random selection</h3>
            <p>
                This function iteratively selects <code>N/2</code> pairs without replacement and builds the list of
                queen positions.
            </p>
            <div class="code-block">
                <pre><code>def create_list(pairs, board_size):
    stack = pairs.copy()
    selected_pairs = []
    for _ in range(board_size // 2):
        if not stack:
            return None
        index = random.randint(0, len(stack) - 1)
        pair = stack.pop(index)
        selected_pairs.append(pair)
    
    array = []
    for pair in selected_pairs:
        array.append(pair[0])
        array.append(pair[1])
    return array</code></pre>
            </div>

            <h3>3. Solution validation</h3>
            <p>
                This function checks that no two queens share a column or diagonal (one queen per row is already
                guaranteed since we place each queen in a distinct row).
            </p>
            <div class="code-block">
                <pre><code>def validation(array):
    length = len(array)
    for i in range(length):
        for j in range(i + 1, length):
            # Check column
            if array[i] == array[j]:
                return False
            # Check diagonal
            if abs(array[i] - array[j]) == abs(i - j):
                return False
    return True</code></pre>
            </div>

            <h3>4. Uniqueness check</h3>
            <p>
                This function checks whether the solution has already been found. Uniqueness is determined by
                comparing the new solution with the list of stored solutions.
            </p>
            <div class="code-block">
                <pre><code>def check(array, arrays):
    return array not in arrays</code></pre>
            </div>
        </section>

        <section id="function-reference" class="section">
            <h2><span class="section-icon"></span>5. Function Reference</h2>

            <div class="card">
                <h3>calculate_pairs(board_size: int) ‚Üí list</h3>
                <p><strong>Purpose:</strong> Generate all valid (i, j) pairs for an N√óN board.</p>

                <table style="margin-top: var(--spacing-md);">
                    <tr>
                        <td style="width: 30%;"><strong>Input</strong></td>
                        <td><code>board_size</code> - Board size (N)</td>
                    </tr>
                    <tr>
                        <td><strong>Output</strong></td>
                        <td>List of [i, j] pairs</td>
                    </tr>
                    <tr>
                        <td><strong>Time Complexity</strong></td>
                        <td><span class="badge primary">O(N¬≤)</span></td>
                    </tr>
                    <tr>
                        <td><strong>Space Complexity</strong></td>
                        <td><span class="badge primary">O(N¬≤)</span></td>
                    </tr>
                </table>
            </div>

            <div class="card">
                <h3>create_list(pairs: list, board_size: int) ‚Üí list | None</h3>
                <p><strong>Purpose:</strong> Randomly select N/2 pairs and build the queen list.</p>

                <table style="margin-top: var(--spacing-md);">
                    <tr>
                        <td style="width: 30%;"><strong>Input</strong></td>
                        <td>
                            <code>pairs</code> - Pre-computed pairs list<br>
                            <code>board_size</code> - N
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Output</strong></td>
                        <td>List of N column positions, or None if stack exhausted</td>
                    </tr>
                    <tr>
                        <td><strong>Time Complexity</strong></td>
                        <td><span class="badge primary">O(N)</span></td>
                    </tr>
                </table>
            </div>

            <div class="card">
                <h3>validation(array: list) ‚Üí bool</h3>
                <p><strong>Purpose:</strong> Verify that no two queens attack each other.</p>

                <table style="margin-top: var(--spacing-md);">
                    <tr>
                        <td style="width: 30%;"><strong>Input</strong></td>
                        <td><code>array</code> - List of queen positions</td>
                    </tr>
                    <tr>
                        <td><strong>Output</strong></td>
                        <td>True if valid, False if invalid</td>
                    </tr>
                    <tr>
                        <td><strong>Time Complexity</strong></td>
                        <td><span class="badge primary">O(N¬≤)</span></td>
                    </tr>
                </table>
            </div>

            <div class="card">
                <h3>check(array: list, arrays: list) ‚Üí bool</h3>
                <p><strong>Purpose:</strong> Check solution uniqueness.</p>

                <table style="margin-top: var(--spacing-md);">
                    <tr>
                        <td style="width: 30%;"><strong>Input</strong></td>
                        <td>
                            <code>array</code> - New solution<br>
                            <code>arrays</code> - List of found solutions
                        </td>
                    </tr>
                    <tr>
                        <td><strong>Output</strong></td>
                        <td>True if unique, False if duplicate</td>
                    </tr>
                    <tr>
                        <td><strong>Time Complexity</strong></td>
                        <td><span class="badge primary">O(N √ó M)</span> where M is number of solutions found</td>
                    </tr>
                </table>
            </div>
        </section>

        <section id="performance-analysis" class="section">
            <h2><span class="section-icon"></span>6. Performance Analysis</h2>

            <h3>Benchmark metrics</h3>
            <div class="grid-3">
                <div class="card">
                    <h4>DNA-Inspired Algorithm</h4>
                    <p><strong>Time for N=8:</strong> ~0.001 s</p>
                    <p><strong>Solutions found:</strong> all 92 unique solutions</p>
                </div>
                <div class="card">
                    <h4>Classical Genetic Algorithm</h4>
                    <p><strong>Time for N=8:</strong> ~0.215 s</p>
                    <p><strong>Solutions found:</strong> 92 solutions</p>
                </div>
                <div class="card">
                    <h4>Speedup</h4>
                    <p><strong>Ratio:</strong> 215√ó faster</p>
                    <p><strong>Reason:</strong> Constrained generation vs. random search</p>
                </div>
            </div>

            <h3>Scalability analysis</h3>
            <table>
                <thead>
                    <tr>
                        <th>Board size (N)</th>
                        <th>Number of pairs</th>
                        <th>Search space</th>
                        <th>Approx. time</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>4</td>
                        <td>16</td>
                        <td>16!</td>
                        <td>&lt; 0.001 s</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>64</td>
                        <td>64!</td>
                        <td>~0.001 s</td>
                    </tr>
                    <tr>
                        <td>16</td>
                        <td>256</td>
                        <td>256!</td>
                        <td>~0.05 s</td>
                    </tr>
                    <tr>
                        <td>32</td>
                        <td>1024</td>
                        <td>1024!</td>
                        <td>~2 s</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="comparison" class="section">
            <h2><span class="section-icon"></span>7. Comparison with Classical Genetic Algorithm</h2>

            <h3>Advantages of the DNA approach</h3>
            <div class="grid-2">
                <div class="card">
                    <h4>No fitness function needed</h4>
                    <p>
                        Classical genetic algorithms need a fitness function to score near-optimal solutions. Our
                        approach produces valid solutions directly and removes the need for iterative evolution.
                    </p>
                </div>
                <div class="card">
                    <h4>No crossover or mutation</h4>
                    <p>
                        We do not rely on traditional genetic operators. Instead, we use constrained random selection
                        inspired by DNA rules to generate valid solutions.
                    </p>
                </div>
            </div>
            <div class="grid-2">
                <div class="card">
                    <h4>No generations</h4>
                    <p>
                        Genetic algorithms typically need many generations to converge to good solutions. Our approach
                        produces valid solutions in a single pass.
                    </p>
                </div>
                <div class="card">
                    <h4>Guaranteed valid solutions</h4>
                    <p>
                        Genetic algorithms may produce invalid solutions that require penalty or rejection. Our
                        algorithm guarantees valid solutions by construction.
                    </p>
                </div>
            </div>

            <h3>Disadvantages</h3>
            <div class="info-box">
                <p>
                    The DNA-inspired approach is not designed for general optimization problems. For problems whose
                    search space cannot be easily constrained, classical genetic algorithms may perform better.
                </p>
            </div>
        </section>

        <section id="usage" class="section">
            <h2><span class="section-icon"></span>8. Usage Guide</h2>

            <h3>Complete code example</h3>
            <div class="code-block">
                <pre><code>import random

def calculate_pairs(board_size):
    pairs = []
    for i in range(board_size):
        for j in range(board_size):
            pairs.append([i, j])
    return pairs

def create_list(pairs, board_size):
    stack = pairs.copy()
    selected_pairs = []
    for _ in range(board_size // 2):
        if not stack:
            return None
        index = random.randint(0, len(stack) - 1)
        pair = stack.pop(index)
        selected_pairs.append(pair)
    
    array = []
    for pair in selected_pairs:
        array.append(pair[0])
        array.append(pair[1])
    return array

def validation(array):
    length = len(array)
    for i in range(length):
        for j in range(i + 1, length):
            if array[i] == array[j]:
                return False
            if abs(array[i] - array[j]) == abs(i - j):
                return False
    return True

def check(array, arrays):
    return array not in arrays

# Main loop
board_size = int(input("Enter board size: "))
user_input = int(input("Enter number of unique solutions you want: "))

pairs = calculate_pairs(board_size)
arrays = []
count = 0

while count < user_input:
    result = create_list(pairs, board_size)
    if result and validation(result) and check(result, arrays):
        arrays.append(result)
        count += 1
        print(f"Solution {count}: {result}")

print(f"\nTotal solutions found: {len(arrays)}")</code></pre>
            </div>

            <h3>Sample output</h3>
            <div class="code-block">
                <pre><code>Enter board size: 8
Enter number of unique solutions you want: 5

Solution 1: [0, 4, 7, 5, 2, 6, 1, 3]
Solution 2: [0, 5, 7, 2, 6, 3, 1, 4]
Solution 3: [0, 6, 3, 5, 7, 1, 4, 2]
Solution 4: [0, 6, 4, 7, 1, 3, 5, 2]
Solution 5: [1, 3, 5, 7, 2, 0, 6, 4]

Total solutions found: 5</code></pre>
            </div>
            <div class="output-figure" style="margin-top: var(--spacing-md);">
                <img src="n-queens-output.png" alt="Sample N-Queens visual output"
                    style="max-width: 100%; height: auto; border-radius: var(--radius-md); box-shadow: var(--shadow-md);">
                <p style="margin-top: var(--spacing-sm); font-size: 0.9em; color: var(--text-secondary);">Sample visual
                    output of the algorithm</p>
            </div>
        </section>

        <section id="complexity" class="section">
            <h2><span class="section-icon"></span>9. Computational Complexity</h2>

            <h3>Time complexity analysis</h3>
            <table>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Complexity</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Pre-compute pairs</td>
                        <td>O(N¬≤)</td>
                        <td>Generate N¬≤ pairs</td>
                    </tr>
                    <tr>
                        <td>Random selection</td>
                        <td>O(N)</td>
                        <td>Select N/2 pairs</td>
                    </tr>
                    <tr>
                        <td>Validation</td>
                        <td>O(N¬≤)</td>
                        <td>Check all queen pairs</td>
                    </tr>
                    <tr>
                        <td>Uniqueness check</td>
                        <td>O(N √ó M)</td>
                        <td>Compare with M solutions</td>
                    </tr>
                    <tr>
                        <td><strong>Total per solution</strong></td>
                        <td><strong>O(N¬≤ + N√óM)</strong></td>
                        <td>To find one valid solution</td>
                    </tr>
                </tbody>
            </table>
            <p><em>Where M is the number of solutions found and K is the average number of attempts per valid
                    solution.</em></p>

            <h3>Space complexity analysis</h3>
            <table>
                <thead>
                    <tr>
                        <th>Data structure</th>
                        <th>Memory</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Pair list</td>
                        <td>O(N¬≤)</td>
                        <td>Store N¬≤ pairs</td>
                    </tr>
                    <tr>
                        <td>Found solutions</td>
                        <td>O(N √ó M)</td>
                        <td>Store M solutions, each of length N</td>
                    </tr>
                    <tr>
                        <td>Temporary stack</td>
                        <td>O(N¬≤)</td>
                        <td>Copy of pair list</td>
                    </tr>
                    <tr>
                        <td><strong>Total</strong></td>
                        <td><strong>O(N¬≤ + N√óM)</strong></td>
                        <td>Total space required</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="limitations" class="section">
            <h2><span class="section-icon"></span>10. Limitations and Edge Cases</h2>

            <h3>Known Limitations</h3>

            <h4>1. No Guarantee of Termination</h4>
            <p>
                The algorithm can theoretically run forever if it keeps generating invalid or duplicate
                solutions. While extremely unlikely for small-to-medium N, this is a theoretical weakness.
            </p>
            <p><strong>Mitigation:</strong> Add a maximum attempts counter:</p>
            <div class="code-block">
                <pre><code>max_attempts = 10000
attempts = 0
while count < user_input and attempts < max_attempts:
    result = create_list(pairs, board_size)
    attempts += 1
    # ... rest of validation logic</code></pre>
            </div>

            <h4>2. Stack Exhaustion in create_list</h4>
            <p>
                For certain board sizes or random sequences, the stack may become empty before completing
                N/2 pair selections, causing create_list to return None.
            </p>
            <p><strong>Frequency:</strong> Increases with larger N and certain N values</p>
            <p><strong>Current Handling:</strong> Returns None, which is filtered out in the main loop</p>

            <h4>3. Inefficient Uniqueness Checking</h4>
            <p>
                The check() function uses list membership test, which is O(N √ó M) where M is the number
                of solutions found. For large M, this becomes a bottleneck.
            </p>
            <p><strong>Improvement:</strong> Use a set of tuples:</p>
            <div class="code-block">
                <pre><code>arrays_set = set()
# ...
if result and validation(result):
    result_tuple = tuple(result)
    if result_tuple not in arrays_set:
        arrays_set.add(result_tuple)
        arrays.append(result)
        count += 1</code></pre>
            </div>

            <div class="grid-3">
                <div class="card">
                    <h4>Theoretical Weaknesses</h4>
                    <p>No guarantee of termination; theoretical possibility of infinite loops if no solutions are
                        found.</p>
                </div>
                <div class="card">
                    <h4>Scalability</h4>
                    <p>Memory pressure increases at O(N¬≤) for the pairs list; N > 100 becomes expensive.</p>
                </div>
                <div class="card">
                    <h4>Impossible Cases</h4>
                    <p>N=2 and N=3 have no solutions; the algorithm will run indefinitely without early exit logic.</p>
                </div>
            </div>
        </section>

        <section id="future-work" class="section">
            <h2><span class="section-icon"></span>11. Future Enhancements</h2>
            <div class="card">
                <ul>
                    <li><strong>Adaptive Selection:</strong> Weighting pairs by success rate.</li>
                    <li><strong>Hybrid Mode:</strong> Fallback to backtracking for difficult cases.</li>
                    <li><strong>Parallelism:</strong> Multiprocessing for large-scale searches.</li>
                    <li><strong>Symmetry Breaking:</strong> Filtering rotations and reflections.</li>
                </ul>
            </div>
        </section>

        <section id="conclusion" class="section">
            <h2>Conclusion</h2>
            <p>
                This DNA-inspired approach demonstrates that biological principles can inspire effective computational
                algorithms. By translating DNA base-pairing rules into constraint-based generation, we achieve a
                <strong>215√ó speedup</strong> over classical genetic algorithms.
            </p>
        </section>
    </div> <!-- End container -->

    <!-- Voting System Section -->
    <div class="container" style="margin-top: 2rem; margin-bottom: 4rem;">
        <div class="info-box" style="text-align: center;">
            <h3>Was this documentation helpful?</h3>
            <p>Your feedback helps improve our research documentation.</p>
            <div class="voting-container">
                <button class="vote-btn" id="upBtn" onclick="handleVote('up')">
                    <span class="vote-icon">üëç</span>
                    <span class="vote-count" id="upCount" data-count="0"></span>
                </button>
                <button class="vote-btn" id="downBtn" onclick="handleVote('down')">
                    <span class="vote-icon">üëé</span>
                    <span class="vote-count" id="downCount" data-count="0"></span>
                </button>
            </div>
        </div>
    </div>

    <!-- Voting System Scripts -->
    <script>
        const pageId = 'genetic-algorithm-docs';

        async function fetchVoteCounts() {
            try {
                const upRes = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://hits.seeyoufarm.com/api/count/incr/badge.json?url=https://artarazaz.github.io/${pageId}-ups`)}`);
                const downRes = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(`https://hits.seeyoufarm.com/api/count/incr/badge.json?url=https://artarazaz.github.io/${pageId}-downs`)}`);

                if (upRes.ok) {
                    const data = await upRes.json();
                    const hits = JSON.parse(data.contents).value;
                    const countEl = document.getElementById('upCount');
                    countEl.innerText = hits.toLocaleString();
                    countEl.setAttribute('data-count', hits);
                }
                if (downRes.ok) {
                    const data = await downRes.json();
                    const hits = JSON.parse(data.contents).value;
                    const countEl = document.getElementById('downCount');
                    countEl.innerText = hits.toLocaleString();
                    countEl.setAttribute('data-count', hits);
                }
            } catch (e) {
                console.error('Error fetching votes:', e);
            }
        }

        async function handleVote(type) {
            const voteKey = `vote_${pageId}`;
            if (localStorage.getItem(voteKey)) return;

            const countElement = document.getElementById(`${type}Count`);
            const hitUrl = `https://hits.seeyoufarm.com/api/count/incr/badge.json?url=https://artarazaz.github.io/${pageId}-${type}s`;

            document.getElementById(`${type}Btn`).classList.add('active');
            localStorage.setItem(voteKey, type);

            try {
                const res = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(hitUrl)}`);
                if (res.ok) {
                    const data = await res.json();
                    const hits = JSON.parse(data.contents).value;
                    countElement.innerText = hits.toLocaleString();
                    countElement.setAttribute('data-count', hits);
                }
            } catch (e) { }
        }

        fetchVoteCounts();

        // Check for previous vote
        const voteKey = `vote_${pageId}`;
        const previousVote = localStorage.getItem(voteKey);
        if (previousVote) {
            document.getElementById(`${previousVote}Btn`).classList.add('active');
        }
    </script>

    <div class="footer">
        <div class="footer-content">
            <div class="footer-links">
                <a href="../index_en.html" class="footer-link">Home</a>
                <a href="../projects_en.html" class="footer-link">Projects</a>
                <a href="../CV.html" class="footer-link">CV</a>
                <a href="../aboutme_en.html" class="footer-link">About Me</a>
                <a href="../contact_me_en.html" class="footer-link">Contact Me</a>
            </div>

            <div class="visitor-counter">
                <span>Total Visits:</span>
                <span id="hitCount">...</span>
            </div>

            <p class="copyright">¬© 2026 Ali-Asghar Razazpour. All rights reserved.</p>
        </div>
    </div>
    <script>
        async function updateCounter() {
            const countElement = document.getElementById('hitCount');
            try {
                const localRes = await fetch('https://artarazaz.github.io/visitor-data.json');
                if (localRes.ok) {
                    const localData = await localRes.json();
                    countElement.innerText = localData.total_visits.toLocaleString();
                    return;
                }
            } catch (e) { }

            try {
                const res = await fetch('https://api.allorigins.win/get?url=' + encodeURIComponent('https://hits.seeyoufarm.com/api/count/incr/badge.json?url=https%3A%2F%2Fartarazaz.github.io%2F'));
                if (res.ok) {
                    const data = await res.json();
                    const hits = JSON.parse(data.contents).value;
                    countElement.innerText = hits.toLocaleString();
                    return;
                }
            } catch (err) { }

            countElement.innerText = '1,240+';
        }
        updateCounter();
    </script>

    <!-- Scroll Reveal Script -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const sections = document.querySelectorAll('.section');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, { threshold: 0.1 });

            sections.forEach(section => observer.observe(section));
        });
    </script>
</body>

</html>